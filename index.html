<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Boating Conditions</title>

<style>
  body { margin:0; background:black; color:white; font-family:Arial, Helvetica, sans-serif; }
  .card{
    border:1px solid #333; border-radius:18px; padding:16px 16px;
    background:rgba(255,255,255,0.06); max-width:760px; margin:0 auto;
  }
  h2 { margin:0 0 10px; font-size:24px; text-align:center; }

  .subhead{
    display:flex; justify-content:space-between; align-items:center;
    gap:10px; margin: 0 0 12px; opacity:.85; font-size:12px;
  }

  /* ONE COLUMN (stacked) */
  .stack{ display:flex; flex-direction:column; gap:10px; }

  .slot{
    border:1px solid #2a2a2a;
    border-radius:14px;
    padding:10px 12px;
    background:rgba(0,0,0,0.15);
  }

  .slotTop{
    display:flex; justify-content:space-between; align-items:center;
    margin-bottom:6px;
  }
  .slotTime{ font-size:15px; font-weight:700; }
  .badge{
    font-size:11px; font-weight:800;
    padding:3px 8px; border-radius:999px;
    border:1px solid currentColor;
    opacity:.95;
  }

  .kv{
    display:grid;
    grid-template-columns: 120px 1fr;
    gap:6px 10px;
    font-size:12px;
    line-height:1.25;
    opacity:.92;
  }
  .k{ opacity:.72; }
  .v{ font-weight:600; }

  .good { color:#8fff9a; }
  .ok   { color:#ffd27d; }
  .bad  { color:#ff9a9a; }

  .meta{
    margin-top:12px; padding-top:10px; border-top:1px solid #222;
    font-size:12px; opacity:.75; line-height:1.35;
  }
  .meta a{ color:#9fd4ff; text-decoration:none; }
  .meta a:hover{ text-decoration:underline; }

  .legend{
    margin-top:10px;
    padding:10px 12px;
    border:1px solid #2a2a2a;
    border-radius:14px;
    background:rgba(0,0,0,0.15);
    font-size:12px;
    line-height:1.35;
  }
  .legend .row{ margin-top:6px; }
  .legend .tag{
    display:inline-block;
    padding:2px 7px;
    border-radius:999px;
    border:1px solid currentColor;
    font-weight:800;
    font-size:11px;
    margin-right:8px;
  }
  .legend small{ opacity:.8; }
</style>
</head>

<body>
<div class="card">
  <h2>Boating Conditions (Today)</h2>

  <div class="subhead">
    <div>Somerset / Brisbane Valley</div>
    <div id="nowLine">–</div>
  </div>

  <div id="slots" class="stack"></div>

  <div class="legend">
    <div><strong>How the rating works</strong> <small>(simple + forgiving)</small></div>
    <div class="row good"><span class="tag">GOOD</span>Effective wind (max of wind/gust) ≤ <strong>18 km/h</strong> and rain risk ≤ <strong>35%</strong></div>
    <div class="row ok"><span class="tag">OK</span>Effective wind ≤ <strong>26 km/h</strong> and rain risk ≤ <strong>60%</strong></div>
    <div class="row bad"><span class="tag">BAD</span>Above those thresholds (wind/gust strong or rain risk high)</div>
    <div class="row"><small>“Effective wind” = max(wind max, gust max). Wave proxy is an estimate for inland conditions.</small></div>
  </div>

  <div class="meta">
    <div id="metaUpdated">Last updated: –</div>
    <div id="metaNext">Next update: –</div>
    <div>
      Source: <a href="https://open-meteo.com/" target="_blank" rel="noreferrer">Open-Meteo</a>
      (hourly wind + gusts + precipitation)
    </div>
  </div>
</div>

<script>
const LAT = -27.1153;
const LON = 152.5565;
const TZ  = "Australia/Brisbane";

const WINDOW_HOURS = 3;
const DAY_SLOTS = [
  { start: 6,  end: 9  },
  { start: 9,  end: 12 },
  { start: 12, end: 15 },
  { start: 15, end: 18 }
];

// Keep refresh frequent so it stays accurate (display is still 3-hour blocks)
const REFRESH_MS = 30 * 60 * 1000;

// Inland wave proxy (cm) based on max “effective wind” (wind/gust)
function waveProxy(effectiveKmh) {
  if (effectiveKmh < 5) return 0;
  if (effectiveKmh < 10) return 10;
  if (effectiveKmh < 15) return 20;
  if (effectiveKmh < 20) return 35;
  if (effectiveKmh < 25) return 50;
  return 70;
}

function windDir(deg) {
  const dirs = ["N","NE","E","SE","S","SW","W","NW"];
  return dirs[Math.round((deg ?? 0) / 45) % 8];
}

function fmtClock(d) {
  return d.toLocaleString("en-AU", { timeZone: TZ, weekday: "short", hour: "2-digit", minute: "2-digit" });
}

function fmtHm(d) {
  return d.toLocaleTimeString("en-AU", { timeZone: TZ, hour: "2-digit", minute: "2-digit" });
}

function dateStrToday() {
  return new Date().toLocaleDateString("en-CA", { timeZone: TZ });
}

function setMetaTimes() {
  const now = new Date();
  const next = new Date(now.getTime() + REFRESH_MS);
  document.getElementById("metaUpdated").textContent = `Last updated: ${fmtClock(now)}`;
  document.getElementById("metaNext").textContent = `Next update: ${fmtClock(next)}`;
  document.getElementById("nowLine").textContent = `Now: ${fmtHm(now)}`;
}

// More forgiving classification (so "all bad" is less common)
function classify(slot) {
  const effective = Math.max(slot.maxWind, slot.maxGust);
  // Use MAX rain probability in the 3-hour window
  const rainRisk = slot.maxProb;

  if (effective <= 18 && rainRisk <= 35) return { label:"GOOD", cls:"good" };
  if (effective <= 26 && rainRisk <= 60) return { label:"OK", cls:"ok" };
  return { label:"BAD", cls:"bad" };
}

function buildSlot(j, dateStr, startHour, endHour) {
  const t = j.hourly.time;
  const wind = j.hourly.wind_speed_10m;
  const gust = j.hourly.wind_gusts_10m;
  const wd = j.hourly.wind_direction_10m;
  const prob = j.hourly.precipitation_probability;
  const mm = j.hourly.precipitation;

  const startIsoPrefix = `${dateStr}T${String(startHour).padStart(2,'0')}:00`;
  const i = t.findIndex(x => x.startsWith(startIsoPrefix));
  if (i < 0) return null;

  let maxWind = 0, sumWind = 0;
  let maxGust = 0, sumGust = 0;
  let maxProb = 0, sumProb = 0;
  let totalMm = 0;
  const dir = wd[i] ?? 0;

  for (let k = 0; k < WINDOW_HOURS; k++) {
    const w = wind[i + k] ?? 0;
    const g = gust?.[i + k] ?? w;
    const p = prob?.[i + k] ?? 0;
    const r = mm?.[i + k] ?? 0;

    maxWind = Math.max(maxWind, w); sumWind += w;
    maxGust = Math.max(maxGust, g); sumGust += g;
    maxProb = Math.max(maxProb, p); sumProb += p;
    totalMm += r;
  }

  const avgWind = sumWind / WINDOW_HOURS;
  const avgGust = sumGust / WINDOW_HOURS;
  const avgProb = sumProb / WINDOW_HOURS;
  const effective = Math.max(maxWind, maxGust);

  return {
    startHour, endHour,
    avgWind, maxWind,
    avgGust, maxGust,
    avgProb, maxProb,
    totalMm,
    dir,
    wave: waveProxy(effective)
  };
}

function renderSlots(slots) {
  const wrap = document.getElementById("slots");
  wrap.innerHTML = "";

  for (const s of slots) {
    if (!s) continue;
    const { label, cls } = classify(s);

    const el = document.createElement("div");
    el.className = `slot ${cls}`;
    el.innerHTML = `
      <div class="slotTop">
        <div class="slotTime">${String(s.startHour).padStart(2,"0")}:00 – ${String(s.endHour).padStart(2,"0")}:00</div>
        <div class="badge">${label}</div>
      </div>

      <div class="kv">
        <div class="k">Wind</div><div class="v">avg ${s.avgWind.toFixed(0)} / max ${s.maxWind.toFixed(0)} km/h (${windDir(s.dir)})</div>
        <div class="k">Gust</div><div class="v">avg ${s.avgGust.toFixed(0)} / max ${s.maxGust.toFixed(0)} km/h</div>
        <div class="k">Wave proxy</div><div class="v">~${s.wave} cm</div>
        <div class="k">Rain</div><div class="v">max ${s.maxProb.toFixed(0)}% · total ${s.totalMm.toFixed(1)} mm</div>
      </div>
    `;
    wrap.appendChild(el);
  }
}

async function load() {
  setMetaTimes();

  const r = await fetch(
    `https://api.open-meteo.com/v1/forecast` +
    `?latitude=${LAT}&longitude=${LON}` +
    `&hourly=wind_speed_10m,wind_gusts_10m,wind_direction_10m,precipitation_probability,precipitation` +
    `&timezone=${encodeURIComponent(TZ)}`,
    { cache: "no-store" }
  );

  const j = await r.json();
  const ds = dateStrToday();

  const slots = DAY_SLOTS.map(s => buildSlot(j, ds, s.start, s.end));
  renderSlots(slots);
}

load();
setInterval(load, REFRESH_MS);
</script>
</body>
</html>
