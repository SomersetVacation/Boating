<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Boating Conditions</title>

<style>
  body { margin:0; background:black; color:white; font-family:Arial, Helvetica, sans-serif; }
  .card {
    border:1px solid #333; border-radius:18px; padding:24px 28px;
    background:rgba(255,255,255,0.06); max-width:580px; margin:0 auto; text-align:center;
  }
  h2 { margin:0 0 14px; font-size:34px; }
  .section { margin-top:20px; }
  .label { font-size:18px; opacity:.8; }
  .time { font-size:36px; font-weight:bold; margin:6px 0; }
  .detail { font-size:18px; opacity:.85; }
  .good { color:#8fff9a; }
  .bad  { color:#ff9a9a; }
  .neutral { color:#ffd27d; }

  .meta {
    margin-top:18px; padding-top:12px; border-top:1px solid #222;
    font-size:14px; opacity:.75; line-height:1.35;
  }
  .meta a{ color:#9fd4ff; text-decoration:none; }
  .meta a:hover{ text-decoration:underline; }

  .note {
    margin-top:12px;
    font-size:14px;
    opacity:0.75;
  }
</style>
</head>

<body>

<div class="card">
  <h2>Boating Conditions</h2>

  <div class="section">
    <div class="label">Best time today (3h)</div>
    <div id="bestToday" class="time good">–</div>
    <div id="bestTodayDetail" class="detail"></div>
  </div>

  <div class="section">
    <div class="label">Worst time today (3h)</div>
    <div id="worstToday" class="time bad">–</div>
    <div id="worstTodayDetail" class="detail"></div>
  </div>

  <div class="section">
    <div class="label">Best time tomorrow (3h)</div>
    <div id="bestTomorrow" class="time neutral">–</div>
    <div id="bestTomorrowDetail" class="detail"></div>
  </div>

  <div id="tieNote" class="note"></div>

  <div class="meta">
    <div id="metaUpdated">Last updated: –</div>
    <div id="metaNext">Next update: –</div>
    <div id="metaSource">
      Source: <a href="https://open-meteo.com/" target="_blank" rel="noreferrer">Open-Meteo</a>
      (hourly forecast: wind + precipitation)
    </div>
  </div>
</div>

<script>
const LAT = -27.1153;
const LON = 152.5565;
const TZ = "Australia/Brisbane";
const WINDOW = 3;
const REFRESH_MS = 30 * 60 * 1000;

// Inland wave proxy (cm) based on MAX wind in the window
function waveProxy(w) {
  if (w < 5) return 0;
  if (w < 10) return 10;
  if (w < 15) return 20;
  if (w < 20) return 35;
  if (w < 25) return 50;
  return 70;
}

function fmtTime(isoOrDate) {
  const d = (isoOrDate instanceof Date) ? isoOrDate : new Date(isoOrDate);
  return d.toLocaleTimeString("en-AU", { timeZone: TZ, hour: "2-digit", minute: "2-digit" });
}

function fmtClock(d) {
  return d.toLocaleString("en-AU", { timeZone: TZ, weekday: "short", hour: "2-digit", minute: "2-digit" });
}

function windDir(deg) {
  const dirs = ["N","NE","E","SE","S","SW","W","NW"];
  return dirs[Math.round(deg / 45) % 8];
}

function setMetaTimes() {
  const now = new Date();
  const next = new Date(now.getTime() + REFRESH_MS);
  document.getElementById("metaUpdated").textContent = `Last updated: ${fmtClock(now)}`;
  document.getElementById("metaNext").textContent = `Next update: ${fmtClock(next)}`;
}

// Better score: average wind matters + any rain matters a lot
function score(avgWind, maxProb, totalMm) {
  return (avgWind * 3) + (maxProb * 1.2) + (totalMm * 80);
}

async function load() {
  setMetaTimes();
  document.getElementById("tieNote").textContent = "";

  const r = await fetch(
    `https://api.open-meteo.com/v1/forecast` +
    `?latitude=${LAT}&longitude=${LON}` +
    `&hourly=wind_speed_10m,wind_direction_10m,precipitation_probability,precipitation` +
    `&timezone=${encodeURIComponent(TZ)}`,
    { cache: "no-store" }
  );

  const j = await r.json();
  const t = j.hourly.time;
  const w = j.hourly.wind_speed_10m;
  const wd = j.hourly.wind_direction_10m;
  const p = j.hourly.precipitation_probability;
  const rmm = j.hourly.precipitation;

  const today = new Date().toLocaleDateString("en-CA", { timeZone: TZ });
  const tomorrow = new Date(Date.now() + 86400000).toLocaleDateString("en-CA", { timeZone: TZ });

  function bestWorst(dateStr) {
    let best = null, worst = null;

    for (let i = 0; i < t.length - WINDOW; i++) {
      if (!t[i].startsWith(dateStr)) continue;

      // NOTE: device is in Brisbane, so this is fine. If not, we'd parse using TZ explicitly.
      const hour = new Date(t[i]).getHours();
      if (hour < 6 || hour > (18 - WINDOW)) continue;

      let maxWind = 0, sumWind = 0;
      let maxProb = 0, sumProb = 0;
      let totalMm = 0;
      let dir = wd[i] ?? 0;

      for (let k = 0; k < WINDOW; k++) {
        const wind = w[i + k] ?? 0;
        const prob = p[i + k] ?? 0;
        const mm = rmm[i + k] ?? 0;

        maxWind = Math.max(maxWind, wind);
        sumWind += wind;

        maxProb = Math.max(maxProb, prob);
        sumProb += prob;

        totalMm += mm;
      }

      const avgWind = sumWind / WINDOW;
      const avgProb = sumProb / WINDOW;
      const sc = score(avgWind, maxProb, totalMm);

      const e = { i, sc, maxWind, avgWind, maxProb, avgProb, totalMm, dir };

      if (!best || sc < best.sc) best = e;
      if (!worst || sc > worst.sc) worst = e;
    }

    return { best, worst };
  }

  function fill(tId, dId, e) {
    if (!e) {
      document.getElementById(tId).textContent = "–";
      document.getElementById(dId).textContent = "";
      return;
    }

    const startDate = new Date(t[e.i]);
    const endDate = new Date(startDate.getTime() + WINDOW * 60 * 60 * 1000);

    document.getElementById(tId).textContent =
      `${fmtTime(startDate)} – ${fmtTime(endDate)}`;

    document.getElementById(dId).textContent =
      `Wind: avg ${e.avgWind.toFixed(0)} / max ${e.maxWind.toFixed(0)} km/h (${windDir(e.dir)}) · ` +
      `Wave height: ~${waveProxy(e.maxWind)} cm · ` +
      `Rain: ≤ ${e.maxProb.toFixed(0)}% (avg ${e.avgProb.toFixed(0)}%) · ` +
      `${e.totalMm.toFixed(1)} mm`;
  }

  const tBW = bestWorst(today);
  const tmBW = bestWorst(tomorrow);

  fill("bestToday", "bestTodayDetail", tBW.best);
  fill("worstToday", "worstTodayDetail", tBW.worst);
  fill("bestTomorrow", "bestTomorrowDetail", tmBW.best);

  // If best and worst look basically the same, tell the user.
  if (tBW.best && tBW.worst) {
    const same =
      Math.abs(tBW.best.avgWind - tBW.worst.avgWind) < 0.5 &&
      Math.abs(tBW.best.maxProb - tBW.worst.maxProb) < 1 &&
      Math.abs(tBW.best.totalMm - tBW.worst.totalMm) < 0.1;

    if (same) {
      document.getElementById("tieNote").textContent =
        "Note: Today’s forecast is very uniform — windows have similar wind/rain, so best & worst may look alike.";
    }
  }
}

load();
setInterval(load, REFRESH_MS);
</script>

</body>
</html>
